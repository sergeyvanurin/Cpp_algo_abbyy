class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        // если размеры не сходятся то сразу можно сказать ответ
        if (s1.size() + s2.size() != s3.size()) {
            return false;
        }

        // для удобства введем размеры нашей матрицы с ответами
        const int x_dim = s2.size() + 1;
        const int y_dim = s1.size() + 1;

        // воспользуемся динамическим программированием. Суть что в ячейке [y][x] находится ответ, можно ли скрестить суффиксы строчки S1 и S2 размером y и x соотвественно в суффикс S3 размером x + y + 1. в конце таблички как раз лежит ответ на задачу
        vector<vector<bool>> din(y_dim, vector<bool>(x_dim));

        // пустые строчки всегда можно скрестить в пустую строчку
        din[0][0] = true;
        
        // теперь пройдемся по всей матрице. Если y = 0 то мы хотим начать с x = 1 так как (0;0) уже заполнили. Для этого напишеи x = 1 - (y != 0). x и y это координаты в матрице
        for (int y = 0; y < y_dim; y++) {
            for (int x = 1 - (y != 0); x < x_dim; x++) {
                // для читабельности выведем эти рассчеты в отдельные переменные. Отсечем заранее варианты где x = 0 или y = 0 с помощью тернарного оператора. Эти рассчеты проверяют, что скрещивание возможно с прошлого шага + новый символ совпадает со следующим символом s3
                const auto s2_match = (x != 0) ? din[y][x-1] && s2[x-1] == s3[x+y-1] : false; // flase не имеет особо смысловой нагрузки просто надо что то положить в переменную.
                const auto s1_match = (y != 0) ? din[y-1][x] && s1[y-1] == s3[x+y-1] : false; 
                if (y == 0) { // если y = 0 то значит пытаемя скрестить с суффиксом s1 размера 0. Значит достаточно проверить что s2 матчится с s3. 
                    din[y][x] = s2_match;
                }
                else if (x == 0) { // аналогично но для s1
                    din[y][x] = s1_match;
                }
                else { // тут проверим оба условия, но нас устроить если хотя бы одно работает
                    din[y][x] = s1_match || s2_match;
                }
            }
        }

        return din[y_dim-1][x_dim-1];
    }
};